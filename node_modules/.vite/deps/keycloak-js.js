import {
  __privateAdd,
  __privateGet,
  __privateMethod,
  __privateSet,
  __publicField
} from "./chunk-SNAQBZPT.js";

// node_modules/keycloak-js/lib/keycloak.js
var CONTENT_TYPE_JSON = "application/json";
var _refreshQueue, _adapter, _useNonce, _callbackStorage, _logInfo, _logWarn, _loginIframe, _config, _Keycloak_instances, loadAdapter_fn, loadDefaultAdapter_fn, loadCordovaAdapter_fn, loadCordovaNativeAdapter_fn, loadConfig_fn, setupEndpoints_fn, loadOidcConfig_fn, setupOidcEndpoints_fn, check3pCookiesSupported_fn, processInit_fn, setupCheckLoginIframe_fn, checkLoginIframe_fn, checkSsoSilently_fn, parseCallback_fn, parseCallbackUrl_fn, parseCallbackParams_fn, processCallback_fn, scheduleCheckIframe_fn, setToken_fn, getRealmUrl_fn, createLogger_fn;
var Keycloak = class {
  /**
   * @param {KeycloakConfig} config
   */
  constructor(config) {
    __privateAdd(this, _Keycloak_instances);
    /** @type {Pick<PromiseWithResolvers<boolean>, 'resolve' | 'reject'>[]} */
    __privateAdd(this, _refreshQueue, []);
    /** @type {KeycloakAdapter} */
    __privateAdd(this, _adapter);
    /** @type {boolean} */
    __privateAdd(this, _useNonce, true);
    /** @type {CallbackStorage} */
    __privateAdd(this, _callbackStorage);
    __privateAdd(this, _logInfo, __privateMethod(this, _Keycloak_instances, createLogger_fn).call(this, console.info));
    __privateAdd(this, _logWarn, __privateMethod(this, _Keycloak_instances, createLogger_fn).call(this, console.warn));
    /** @type {LoginIframe} */
    __privateAdd(this, _loginIframe, {
      enable: true,
      callbackList: [],
      interval: 5
    });
    /** @type {KeycloakConfig} config */
    __privateAdd(this, _config);
    __publicField(this, "didInitialize", false);
    __publicField(this, "authenticated", false);
    __publicField(this, "loginRequired", false);
    /** @type {KeycloakResponseMode} */
    __publicField(this, "responseMode", "fragment");
    /** @type {KeycloakResponseType} */
    __publicField(this, "responseType", "code");
    /** @type {KeycloakFlow} */
    __publicField(this, "flow", "standard");
    /** @type {number?} */
    __publicField(this, "timeSkew", null);
    /** @type {string=} */
    __publicField(this, "redirectUri");
    /** @type {string=} */
    __publicField(this, "silentCheckSsoRedirectUri");
    /** @type {boolean} */
    __publicField(this, "silentCheckSsoFallback", true);
    /** @type {KeycloakPkceMethod} */
    __publicField(this, "pkceMethod", "S256");
    __publicField(this, "enableLogging", false);
    /** @type {'GET' | 'POST'} */
    __publicField(this, "logoutMethod", "GET");
    /** @type {string=} */
    __publicField(this, "scope");
    __publicField(this, "messageReceiveTimeout", 1e4);
    /** @type {string=} */
    __publicField(this, "idToken");
    /** @type {KeycloakTokenParsed=} */
    __publicField(this, "idTokenParsed");
    /** @type {string=} */
    __publicField(this, "token");
    /** @type {KeycloakTokenParsed=} */
    __publicField(this, "tokenParsed");
    /** @type {string=} */
    __publicField(this, "refreshToken");
    /** @type {KeycloakTokenParsed=} */
    __publicField(this, "refreshTokenParsed");
    /** @type {string=} */
    __publicField(this, "clientId");
    /** @type {string=} */
    __publicField(this, "sessionId");
    /** @type {string=} */
    __publicField(this, "subject");
    /** @type {string=} */
    __publicField(this, "authServerUrl");
    /** @type {string=} */
    __publicField(this, "realm");
    /** @type {KeycloakRoles=} */
    __publicField(this, "realmAccess");
    /** @type {KeycloakResourceAccess=} */
    __publicField(this, "resourceAccess");
    /** @type {KeycloakProfile=} */
    __publicField(this, "profile");
    /** @type {{}=} */
    __publicField(this, "userInfo");
    /** @type {Endpoints} */
    __publicField(this, "endpoints");
    /** @type {number=} */
    __publicField(this, "tokenTimeoutHandle");
    /** @type {() => void=} */
    __publicField(this, "onAuthSuccess");
    /** @type {(errorData?: KeycloakError) => void=} */
    __publicField(this, "onAuthError");
    /** @type {() => void=} */
    __publicField(this, "onAuthRefreshSuccess");
    /** @type {() => void=} */
    __publicField(this, "onAuthRefreshError");
    /** @type {() => void=} */
    __publicField(this, "onTokenExpired");
    /** @type {() => void=} */
    __publicField(this, "onAuthLogout");
    /** @type {(authenticated: boolean) => void=} */
    __publicField(this, "onReady");
    /** @type {(status: 'success' | 'cancelled' | 'error', action: string) => void=} */
    __publicField(this, "onActionUpdate");
    /**
     * @param {KeycloakInitOptions} initOptions
     * @returns {Promise<boolean>}
     */
    __publicField(this, "init", async (initOptions = {}) => {
      var _a;
      if (this.didInitialize) {
        throw new Error("A 'Keycloak' instance can only be initialized once.");
      }
      this.didInitialize = true;
      __privateSet(this, _callbackStorage, createCallbackStorage());
      const adapters = ["default", "cordova", "cordova-native"];
      if (typeof initOptions.adapter === "string" && adapters.includes(initOptions.adapter)) {
        __privateSet(this, _adapter, __privateMethod(this, _Keycloak_instances, loadAdapter_fn).call(this, initOptions.adapter));
      } else if (typeof initOptions.adapter === "object") {
        __privateSet(this, _adapter, initOptions.adapter);
      } else if ("Cordova" in window || "cordova" in window) {
        __privateSet(this, _adapter, __privateMethod(this, _Keycloak_instances, loadAdapter_fn).call(this, "cordova"));
      } else {
        __privateSet(this, _adapter, __privateMethod(this, _Keycloak_instances, loadAdapter_fn).call(this, "default"));
      }
      if (typeof initOptions.useNonce !== "undefined") {
        __privateSet(this, _useNonce, initOptions.useNonce);
      }
      if (typeof initOptions.checkLoginIframe !== "undefined") {
        __privateGet(this, _loginIframe).enable = initOptions.checkLoginIframe;
      }
      if (initOptions.checkLoginIframeInterval) {
        __privateGet(this, _loginIframe).interval = initOptions.checkLoginIframeInterval;
      }
      if (initOptions.onLoad === "login-required") {
        this.loginRequired = true;
      }
      if (initOptions.responseMode) {
        if (initOptions.responseMode === "query" || initOptions.responseMode === "fragment") {
          this.responseMode = initOptions.responseMode;
        } else {
          throw new Error("Invalid value for responseMode");
        }
      }
      if (initOptions.flow) {
        switch (initOptions.flow) {
          case "standard":
            this.responseType = "code";
            break;
          case "implicit":
            this.responseType = "id_token token";
            break;
          case "hybrid":
            this.responseType = "code id_token token";
            break;
          default:
            throw new Error("Invalid value for flow");
        }
        this.flow = initOptions.flow;
      }
      if (typeof initOptions.timeSkew === "number") {
        this.timeSkew = initOptions.timeSkew;
      }
      if (initOptions.redirectUri) {
        this.redirectUri = initOptions.redirectUri;
      }
      if (initOptions.silentCheckSsoRedirectUri) {
        this.silentCheckSsoRedirectUri = initOptions.silentCheckSsoRedirectUri;
      }
      if (typeof initOptions.silentCheckSsoFallback === "boolean") {
        this.silentCheckSsoFallback = initOptions.silentCheckSsoFallback;
      }
      if (typeof initOptions.pkceMethod !== "undefined") {
        if (initOptions.pkceMethod !== "S256" && initOptions.pkceMethod !== false) {
          throw new TypeError(`Invalid value for pkceMethod', expected 'S256' or false but got ${initOptions.pkceMethod}.`);
        }
        this.pkceMethod = initOptions.pkceMethod;
      }
      if (typeof initOptions.enableLogging === "boolean") {
        this.enableLogging = initOptions.enableLogging;
      }
      if (initOptions.logoutMethod === "POST") {
        this.logoutMethod = "POST";
      }
      if (typeof initOptions.scope === "string") {
        this.scope = initOptions.scope;
      }
      if (typeof initOptions.messageReceiveTimeout === "number" && initOptions.messageReceiveTimeout > 0) {
        this.messageReceiveTimeout = initOptions.messageReceiveTimeout;
      }
      await __privateMethod(this, _Keycloak_instances, loadConfig_fn).call(this);
      await __privateMethod(this, _Keycloak_instances, check3pCookiesSupported_fn).call(this);
      await __privateMethod(this, _Keycloak_instances, processInit_fn).call(this, initOptions);
      (_a = this.onReady) == null ? void 0 : _a.call(this, this.authenticated);
      return this.authenticated;
    });
    /**
     * @param {KeycloakLoginOptions} [options]
     * @returns {Promise<void>}
     */
    __publicField(this, "login", (options) => {
      return __privateGet(this, _adapter).login(options);
    });
    /**
     * @param {KeycloakLoginOptions} [options]
     * @returns {Promise<string>}
     */
    __publicField(this, "createLoginUrl", async (options) => {
      const state = createUUID();
      const nonce = createUUID();
      const redirectUri = __privateGet(this, _adapter).redirectUri(options);
      const callbackState = {
        state,
        nonce,
        redirectUri,
        loginOptions: options
      };
      if (options == null ? void 0 : options.prompt) {
        callbackState.prompt = options.prompt;
      }
      const url = (options == null ? void 0 : options.action) === "register" ? this.endpoints.register() : this.endpoints.authorize();
      let scope = (options == null ? void 0 : options.scope) || this.scope;
      const scopeValues = scope ? scope.split(" ") : [];
      if (!scopeValues.includes("openid")) {
        scopeValues.unshift("openid");
      }
      scope = scopeValues.join(" ");
      const params = new URLSearchParams([
        [
          "client_id",
          /** @type {string} */
          this.clientId
        ],
        ["redirect_uri", redirectUri],
        ["state", state],
        ["response_mode", this.responseMode],
        ["response_type", this.responseType],
        ["scope", scope]
      ]);
      if (__privateGet(this, _useNonce)) {
        params.append("nonce", nonce);
      }
      if (options == null ? void 0 : options.prompt) {
        params.append("prompt", options.prompt);
      }
      if (typeof (options == null ? void 0 : options.maxAge) === "number") {
        params.append("max_age", options.maxAge.toString());
      }
      if (options == null ? void 0 : options.loginHint) {
        params.append("login_hint", options.loginHint);
      }
      if (options == null ? void 0 : options.idpHint) {
        params.append("kc_idp_hint", options.idpHint);
      }
      if ((options == null ? void 0 : options.action) && options.action !== "register") {
        params.append("kc_action", options.action);
      }
      if (options == null ? void 0 : options.locale) {
        params.append("ui_locales", options.locale);
      }
      if (options == null ? void 0 : options.acr) {
        params.append("claims", buildClaimsParameter(options.acr));
      }
      if (options == null ? void 0 : options.acrValues) {
        params.append("acr_values", options.acrValues);
      }
      if (this.pkceMethod) {
        try {
          const codeVerifier = generateCodeVerifier(96);
          const pkceChallenge = await generatePkceChallenge(this.pkceMethod, codeVerifier);
          callbackState.pkceCodeVerifier = codeVerifier;
          params.append("code_challenge", pkceChallenge);
          params.append("code_challenge_method", this.pkceMethod);
        } catch (error) {
          throw new Error("Failed to generate PKCE challenge.", { cause: error });
        }
      }
      __privateGet(this, _callbackStorage).add(callbackState);
      return `${url}?${params.toString()}`;
    });
    /**
     * @param {KeycloakLogoutOptions} [options]
     * @returns {Promise<void>}
     */
    __publicField(this, "logout", (options) => {
      return __privateGet(this, _adapter).logout(options);
    });
    /**
     * @param {KeycloakLogoutOptions} [options]
     * @returns {string}
     */
    __publicField(this, "createLogoutUrl", (options) => {
      const logoutMethod = (options == null ? void 0 : options.logoutMethod) ?? this.logoutMethod;
      const url = this.endpoints.logout();
      if (logoutMethod === "POST") {
        return url;
      }
      const params = new URLSearchParams([
        [
          "client_id",
          /** @type {string} */
          this.clientId
        ],
        ["post_logout_redirect_uri", __privateGet(this, _adapter).redirectUri(options)]
      ]);
      if (this.idToken) {
        params.append("id_token_hint", this.idToken);
      }
      return `${url}?${params.toString()}`;
    });
    /**
     * @param {KeycloakRegisterOptions} [options]
     * @returns {Promise<void>}
     */
    __publicField(this, "register", (options) => {
      return __privateGet(this, _adapter).register(options);
    });
    /**
     * @param {KeycloakRegisterOptions} [options]
     * @returns {Promise<string>}
     */
    __publicField(this, "createRegisterUrl", (options) => {
      return this.createLoginUrl({ ...options, action: "register" });
    });
    /**
     * @param {KeycloakAccountOptions} [options]
     * @returns {string}
     */
    __publicField(this, "createAccountUrl", (options) => {
      const url = __privateMethod(this, _Keycloak_instances, getRealmUrl_fn).call(this);
      if (!url) {
        throw new Error("Unable to create account URL, make sure the adapter is not configured using a generic OIDC provider.");
      }
      const params = new URLSearchParams([
        [
          "referrer",
          /** @type {string} */
          this.clientId
        ],
        ["referrer_uri", __privateGet(this, _adapter).redirectUri(options)]
      ]);
      return `${url}/account?${params.toString()}`;
    });
    /**
     * @returns {Promise<void>}
     */
    __publicField(this, "accountManagement", () => {
      return __privateGet(this, _adapter).accountManagement();
    });
    /**
     * @param {string} role
     * @returns {boolean}
     */
    __publicField(this, "hasRealmRole", (role) => {
      const access = this.realmAccess;
      return !!access && access.roles.indexOf(role) >= 0;
    });
    /**
     * @param {string} role
     * @param {string} [resource]
     * @returns {boolean}
     */
    __publicField(this, "hasResourceRole", (role, resource) => {
      if (!this.resourceAccess) {
        return false;
      }
      const access = this.resourceAccess[resource || /** @type {string} */
      this.clientId];
      return !!access && access.roles.indexOf(role) >= 0;
    });
    /**
     * @returns {Promise<KeycloakProfile>}
     */
    __publicField(this, "loadUserProfile", async () => {
      const realmUrl = __privateMethod(this, _Keycloak_instances, getRealmUrl_fn).call(this);
      if (!realmUrl) {
        throw new Error("Unable to load user profile, make sure the adapter is not configured using a generic OIDC provider.");
      }
      const url = `${realmUrl}/account`;
      const profile = await fetchJSON(url, {
        headers: [buildAuthorizationHeader(this.token)]
      });
      return this.profile = profile;
    });
    /**
     * @returns {Promise<{}>}
     */
    __publicField(this, "loadUserInfo", async () => {
      const url = this.endpoints.userinfo();
      const userInfo = await fetchJSON(url, {
        headers: [buildAuthorizationHeader(this.token)]
      });
      return this.userInfo = userInfo;
    });
    /**
     * @param {number} [minValidity]
     * @returns {boolean}
     */
    __publicField(this, "isTokenExpired", (minValidity) => {
      if (!this.tokenParsed || !this.refreshToken && this.flow !== "implicit") {
        throw new Error("Not authenticated");
      }
      if (this.timeSkew == null) {
        __privateGet(this, _logInfo).call(this, "[KEYCLOAK] Unable to determine if token is expired as timeskew is not set");
        return true;
      }
      if (typeof this.tokenParsed.exp !== "number") {
        return false;
      }
      let expiresIn = this.tokenParsed.exp - Math.ceil((/* @__PURE__ */ new Date()).getTime() / 1e3) + this.timeSkew;
      if (minValidity) {
        if (isNaN(minValidity)) {
          throw new Error("Invalid minValidity");
        }
        expiresIn -= minValidity;
      }
      return expiresIn < 0;
    });
    /**
     * @param {number} minValidity
     * @returns {Promise<boolean>}
     */
    __publicField(this, "updateToken", async (minValidity) => {
      var _a, _b;
      if (!this.refreshToken) {
        throw new Error("Unable to update token, no refresh token available.");
      }
      minValidity = minValidity || 5;
      if (__privateGet(this, _loginIframe).enable) {
        await __privateMethod(this, _Keycloak_instances, checkLoginIframe_fn).call(this);
      }
      let refreshToken = false;
      if (minValidity === -1) {
        refreshToken = true;
        __privateGet(this, _logInfo).call(this, "[KEYCLOAK] Refreshing token: forced refresh");
      } else if (!this.tokenParsed || this.isTokenExpired(minValidity)) {
        refreshToken = true;
        __privateGet(this, _logInfo).call(this, "[KEYCLOAK] Refreshing token: token expired");
      }
      if (!refreshToken) {
        return false;
      }
      const { promise, resolve, reject } = Promise.withResolvers();
      __privateGet(this, _refreshQueue).push({ resolve, reject });
      if (__privateGet(this, _refreshQueue).length === 1) {
        const url = this.endpoints.token();
        let timeLocal = (/* @__PURE__ */ new Date()).getTime();
        try {
          const response = await fetchRefreshToken(
            url,
            this.refreshToken,
            /** @type {string} */
            this.clientId
          );
          __privateGet(this, _logInfo).call(this, "[KEYCLOAK] Token refreshed");
          timeLocal = (timeLocal + (/* @__PURE__ */ new Date()).getTime()) / 2;
          __privateMethod(this, _Keycloak_instances, setToken_fn).call(this, response.access_token, response.refresh_token, response.id_token, timeLocal);
          (_a = this.onAuthRefreshSuccess) == null ? void 0 : _a.call(this);
          for (let p = __privateGet(this, _refreshQueue).pop(); p != null; p = __privateGet(this, _refreshQueue).pop()) {
            p.resolve(true);
          }
        } catch (error) {
          __privateGet(this, _logWarn).call(this, "[KEYCLOAK] Failed to refresh token");
          if (error instanceof NetworkError && error.response.status === 400) {
            this.clearToken();
          }
          (_b = this.onAuthRefreshError) == null ? void 0 : _b.call(this);
          for (let p = __privateGet(this, _refreshQueue).pop(); p != null; p = __privateGet(this, _refreshQueue).pop()) {
            p.reject(error);
          }
        }
      }
      return await promise;
    });
    __publicField(this, "clearToken", () => {
      var _a;
      if (this.token) {
        __privateMethod(this, _Keycloak_instances, setToken_fn).call(this);
        (_a = this.onAuthLogout) == null ? void 0 : _a.call(this);
        if (this.loginRequired) {
          this.login();
        }
      }
    });
    if (typeof config !== "string" && !isObject(config)) {
      throw new Error("The 'Keycloak' constructor must be provided with a configuration object, or a URL to a JSON configuration file.");
    }
    if (isObject(config)) {
      const requiredProperties = "oidcProvider" in config ? ["clientId"] : ["url", "realm", "clientId"];
      for (const property of requiredProperties) {
        if (!(property in config)) {
          throw new Error(`The configuration object is missing the required '${property}' property.`);
        }
      }
    }
    if (!globalThis.isSecureContext) {
      __privateGet(this, _logWarn).call(this, "[KEYCLOAK] Keycloak JS must be used in a 'secure context' to function properly as it relies on browser APIs that are otherwise not available.\nContinuing to run your application insecurely will lead to unexpected behavior and breakage.\n\nFor more information see: https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts");
    }
    __privateSet(this, _config, config);
  }
};
_refreshQueue = new WeakMap();
_adapter = new WeakMap();
_useNonce = new WeakMap();
_callbackStorage = new WeakMap();
_logInfo = new WeakMap();
_logWarn = new WeakMap();
_loginIframe = new WeakMap();
_config = new WeakMap();
_Keycloak_instances = new WeakSet();
/**
 * @param {"default" | "cordova" | "cordova-native"} type
 * @returns {KeycloakAdapter}
 */
loadAdapter_fn = function(type) {
  if (type === "default") {
    return __privateMethod(this, _Keycloak_instances, loadDefaultAdapter_fn).call(this);
  }
  if (type === "cordova") {
    __privateGet(this, _loginIframe).enable = false;
    return __privateMethod(this, _Keycloak_instances, loadCordovaAdapter_fn).call(this);
  }
  if (type === "cordova-native") {
    __privateGet(this, _loginIframe).enable = false;
    return __privateMethod(this, _Keycloak_instances, loadCordovaNativeAdapter_fn).call(this);
  }
  throw new Error("invalid adapter type: " + type);
};
/**
 * @returns {KeycloakAdapter}
 */
loadDefaultAdapter_fn = function() {
  const redirectUri = (options) => {
    return (options == null ? void 0 : options.redirectUri) || this.redirectUri || globalThis.location.href;
  };
  return {
    login: async (options) => {
      window.location.assign(await this.createLoginUrl(options));
      return await new Promise(() => {
      });
    },
    logout: async (options) => {
      const logoutMethod = (options == null ? void 0 : options.logoutMethod) ?? this.logoutMethod;
      if (logoutMethod === "GET") {
        window.location.replace(this.createLogoutUrl(options));
        return;
      }
      const form = document.createElement("form");
      form.setAttribute("method", "POST");
      form.setAttribute("action", this.createLogoutUrl(options));
      form.style.display = "none";
      const data = {
        id_token_hint: this.idToken,
        client_id: this.clientId,
        post_logout_redirect_uri: redirectUri(options)
      };
      for (const [name, value] of Object.entries(data)) {
        const input = document.createElement("input");
        input.setAttribute("type", "hidden");
        input.setAttribute("name", name);
        input.setAttribute(
          "value",
          /** @type {string} */
          value
        );
        form.appendChild(input);
      }
      document.body.appendChild(form);
      form.submit();
    },
    register: async (options) => {
      window.location.assign(await this.createRegisterUrl(options));
      return await new Promise(() => {
      });
    },
    accountManagement: async () => {
      const accountUrl = this.createAccountUrl();
      if (typeof accountUrl !== "undefined") {
        window.location.href = accountUrl;
      } else {
        throw new Error("Not supported by the OIDC server");
      }
      return await new Promise(() => {
      });
    },
    redirectUri
  };
};
/**
 * @returns {KeycloakAdapter}
 */
loadCordovaAdapter_fn = function() {
  const cordovaOpenWindowWrapper = (loginUrl, target, options) => {
    if (window.cordova && window.cordova.InAppBrowser) {
      return window.cordova.InAppBrowser.open(loginUrl, target, options);
    } else {
      return window.open(loginUrl, target, options);
    }
  };
  const shallowCloneCordovaOptions = (userOptions) => {
    if (userOptions && userOptions.cordovaOptions) {
      return Object.keys(userOptions.cordovaOptions).reduce((options, optionName) => {
        options[optionName] = userOptions.cordovaOptions[optionName];
        return options;
      }, {});
    } else {
      return {};
    }
  };
  const formatCordovaOptions = (cordovaOptions) => {
    return Object.keys(cordovaOptions).reduce((options, optionName) => {
      options.push(optionName + "=" + cordovaOptions[optionName]);
      return options;
    }, []).join(",");
  };
  const createCordovaOptions = (userOptions) => {
    const cordovaOptions = shallowCloneCordovaOptions(userOptions);
    cordovaOptions.location = "no";
    if (userOptions && userOptions.prompt === "none") {
      cordovaOptions.hidden = "yes";
    }
    return formatCordovaOptions(cordovaOptions);
  };
  const getCordovaRedirectUri = () => {
    return this.redirectUri || "http://localhost";
  };
  return {
    login: async (options) => {
      const cordovaOptions = createCordovaOptions(options);
      const loginUrl = await this.createLoginUrl(options);
      const ref = cordovaOpenWindowWrapper(loginUrl, "_blank", cordovaOptions);
      let completed = false;
      let closed = false;
      function closeBrowser() {
        closed = true;
        ref.close();
      }
      ;
      return await new Promise((resolve, reject) => {
        ref.addEventListener("loadstart", async (event) => {
          if (event.url.indexOf(getCordovaRedirectUri()) === 0) {
            const callback = __privateMethod(this, _Keycloak_instances, parseCallback_fn).call(this, event.url);
            try {
              await __privateMethod(this, _Keycloak_instances, processCallback_fn).call(this, callback);
              resolve();
            } catch (error) {
              reject(error);
            }
            closeBrowser();
            completed = true;
          }
        });
        ref.addEventListener("loaderror", async (event) => {
          if (!completed) {
            if (event.url.indexOf(getCordovaRedirectUri()) === 0) {
              const callback = __privateMethod(this, _Keycloak_instances, parseCallback_fn).call(this, event.url);
              try {
                await __privateMethod(this, _Keycloak_instances, processCallback_fn).call(this, callback);
                resolve();
              } catch (error) {
                reject(error);
              }
              closeBrowser();
              completed = true;
            } else {
              reject(new Error("Unable to process login."));
              closeBrowser();
            }
          }
        });
        ref.addEventListener("exit", function(event) {
          if (!closed) {
            reject(new Error("User closed the login window."));
          }
        });
      });
    },
    logout: async (options) => {
      const logoutUrl = this.createLogoutUrl(options);
      const ref = cordovaOpenWindowWrapper(logoutUrl, "_blank", "location=no,hidden=yes,clearcache=yes");
      let error = false;
      ref.addEventListener("loadstart", (event) => {
        if (event.url.indexOf(getCordovaRedirectUri()) === 0) {
          ref.close();
        }
      });
      ref.addEventListener("loaderror", (event) => {
        if (event.url.indexOf(getCordovaRedirectUri()) === 0) {
          ref.close();
        } else {
          error = true;
          ref.close();
        }
      });
      await new Promise((resolve, reject) => {
        ref.addEventListener("exit", () => {
          if (error) {
            reject(new Error("User closed the login window."));
          } else {
            this.clearToken();
            resolve();
          }
        });
      });
    },
    register: async (options) => {
      const registerUrl = await this.createRegisterUrl();
      const cordovaOptions = createCordovaOptions(options);
      const ref = cordovaOpenWindowWrapper(registerUrl, "_blank", cordovaOptions);
      const promise = new Promise((resolve, reject) => {
        ref.addEventListener("loadstart", async (event) => {
          if (event.url.indexOf(getCordovaRedirectUri()) === 0) {
            ref.close();
            const oauth = __privateMethod(this, _Keycloak_instances, parseCallback_fn).call(this, event.url);
            try {
              await __privateMethod(this, _Keycloak_instances, processCallback_fn).call(this, oauth);
              resolve();
            } catch (error) {
              reject(error);
            }
          }
        });
      });
      await promise;
    },
    accountManagement: async () => {
      const accountUrl = this.createAccountUrl();
      if (typeof accountUrl !== "undefined") {
        const ref = cordovaOpenWindowWrapper(accountUrl, "_blank", "location=no");
        ref.addEventListener("loadstart", function(event) {
          if (event.url.indexOf(getCordovaRedirectUri()) === 0) {
            ref.close();
          }
        });
      } else {
        throw new Error("Not supported by the OIDC server");
      }
    },
    redirectUri: () => {
      return getCordovaRedirectUri();
    }
  };
};
/**
 * @returns {KeycloakAdapter}
 */
loadCordovaNativeAdapter_fn = function() {
  return {
    login: async (options) => {
      const loginUrl = await this.createLoginUrl(options);
      await new Promise((resolve, reject) => {
        universalLinks.subscribe("keycloak", async (event) => {
          universalLinks.unsubscribe("keycloak");
          window.cordova.plugins.browsertab.close();
          const oauth = __privateMethod(this, _Keycloak_instances, parseCallback_fn).call(this, event.url);
          try {
            await __privateMethod(this, _Keycloak_instances, processCallback_fn).call(this, oauth);
            resolve();
          } catch (error) {
            reject(error);
          }
        });
        window.cordova.plugins.browsertab.openUrl(loginUrl);
      });
    },
    logout: async (options) => {
      const logoutUrl = this.createLogoutUrl(options);
      await new Promise((resolve) => {
        universalLinks.subscribe("keycloak", () => {
          universalLinks.unsubscribe("keycloak");
          window.cordova.plugins.browsertab.close();
          this.clearToken();
          resolve();
        });
        window.cordova.plugins.browsertab.openUrl(logoutUrl);
      });
    },
    register: async (options) => {
      const registerUrl = await this.createRegisterUrl(options);
      await new Promise((resolve, reject) => {
        universalLinks.subscribe("keycloak", async (event) => {
          universalLinks.unsubscribe("keycloak");
          window.cordova.plugins.browsertab.close();
          const oauth = __privateMethod(this, _Keycloak_instances, parseCallback_fn).call(this, event.url);
          try {
            await __privateMethod(this, _Keycloak_instances, processCallback_fn).call(this, oauth);
            resolve();
          } catch (error) {
            reject(error);
          }
        });
        window.cordova.plugins.browsertab.openUrl(registerUrl);
      });
    },
    accountManagement: async () => {
      const accountUrl = this.createAccountUrl();
      if (typeof accountUrl !== "undefined") {
        window.cordova.plugins.browsertab.openUrl(accountUrl);
      } else {
        throw new Error("Not supported by the OIDC server");
      }
    },
    redirectUri: (options) => {
      if (options && options.redirectUri) {
        return options.redirectUri;
      } else if (this.redirectUri) {
        return this.redirectUri;
      } else {
        return "http://localhost";
      }
    }
  };
};
loadConfig_fn = async function() {
  if (typeof __privateGet(this, _config) === "string") {
    const jsonConfig = await fetchJsonConfig(__privateGet(this, _config));
    this.authServerUrl = jsonConfig["auth-server-url"];
    this.realm = jsonConfig.realm;
    this.clientId = jsonConfig.resource;
    __privateMethod(this, _Keycloak_instances, setupEndpoints_fn).call(this);
  } else {
    this.clientId = __privateGet(this, _config).clientId;
    if ("oidcProvider" in __privateGet(this, _config)) {
      await __privateMethod(this, _Keycloak_instances, loadOidcConfig_fn).call(this, __privateGet(this, _config).oidcProvider);
    } else {
      this.authServerUrl = __privateGet(this, _config).url;
      this.realm = __privateGet(this, _config).realm;
      __privateMethod(this, _Keycloak_instances, setupEndpoints_fn).call(this);
    }
  }
};
/**
 * @returns {void}
 */
setupEndpoints_fn = function() {
  this.endpoints = {
    authorize: () => {
      return __privateMethod(this, _Keycloak_instances, getRealmUrl_fn).call(this) + "/protocol/openid-connect/auth";
    },
    token: () => {
      return __privateMethod(this, _Keycloak_instances, getRealmUrl_fn).call(this) + "/protocol/openid-connect/token";
    },
    logout: () => {
      return __privateMethod(this, _Keycloak_instances, getRealmUrl_fn).call(this) + "/protocol/openid-connect/logout";
    },
    checkSessionIframe: () => {
      return __privateMethod(this, _Keycloak_instances, getRealmUrl_fn).call(this) + "/protocol/openid-connect/login-status-iframe.html";
    },
    thirdPartyCookiesIframe: () => {
      return __privateMethod(this, _Keycloak_instances, getRealmUrl_fn).call(this) + "/protocol/openid-connect/3p-cookies/step1.html";
    },
    register: () => {
      return __privateMethod(this, _Keycloak_instances, getRealmUrl_fn).call(this) + "/protocol/openid-connect/registrations";
    },
    userinfo: () => {
      return __privateMethod(this, _Keycloak_instances, getRealmUrl_fn).call(this) + "/protocol/openid-connect/userinfo";
    }
  };
};
loadOidcConfig_fn = async function(oidcProvider) {
  if (typeof oidcProvider === "string") {
    const url = `${stripTrailingSlash(oidcProvider)}/.well-known/openid-configuration`;
    const openIdConfig = await fetchOpenIdConfig(url);
    __privateMethod(this, _Keycloak_instances, setupOidcEndpoints_fn).call(this, openIdConfig);
  } else {
    __privateMethod(this, _Keycloak_instances, setupOidcEndpoints_fn).call(this, oidcProvider);
  }
};
/**
 * @param {OpenIdProviderMetadata} config
 * @returns {void}
 */
setupOidcEndpoints_fn = function(config) {
  this.endpoints = {
    authorize() {
      return config.authorization_endpoint;
    },
    token() {
      return config.token_endpoint;
    },
    logout() {
      if (!config.end_session_endpoint) {
        throw new Error("Not supported by the OIDC server");
      }
      return config.end_session_endpoint;
    },
    checkSessionIframe() {
      if (!config.check_session_iframe) {
        throw new Error("Not supported by the OIDC server");
      }
      return config.check_session_iframe;
    },
    register() {
      throw new Error('Redirection to "Register user" page not supported in standard OIDC mode');
    },
    userinfo() {
      if (!config.userinfo_endpoint) {
        throw new Error("Not supported by the OIDC server");
      }
      return config.userinfo_endpoint;
    }
  };
};
check3pCookiesSupported_fn = async function() {
  if (!__privateGet(this, _loginIframe).enable && !this.silentCheckSsoRedirectUri || typeof this.endpoints.thirdPartyCookiesIframe !== "function") {
    return;
  }
  const iframe = document.createElement("iframe");
  iframe.setAttribute("src", this.endpoints.thirdPartyCookiesIframe());
  iframe.setAttribute("sandbox", "allow-storage-access-by-user-activation allow-scripts allow-same-origin");
  iframe.setAttribute("title", "keycloak-3p-check-iframe");
  iframe.style.display = "none";
  document.body.appendChild(iframe);
  const promise = new Promise((resolve) => {
    const messageCallback = (event) => {
      if (iframe.contentWindow !== event.source) {
        return;
      }
      if (event.data !== "supported" && event.data !== "unsupported") {
        return;
      } else if (event.data === "unsupported") {
        __privateGet(this, _logWarn).call(this, "[KEYCLOAK] Your browser is blocking access to 3rd-party cookies, this means:\n\n - It is not possible to retrieve tokens without redirecting to the Keycloak server (a.k.a. no support for silent authentication).\n - It is not possible to automatically detect changes to the session status (such as the user logging out in another tab).\n\nFor more information see: https://www.keycloak.org/securing-apps/javascript-adapter#_modern_browsers");
        __privateGet(this, _loginIframe).enable = false;
        if (this.silentCheckSsoFallback) {
          this.silentCheckSsoRedirectUri = void 0;
        }
      }
      document.body.removeChild(iframe);
      window.removeEventListener("message", messageCallback);
      resolve();
    };
    window.addEventListener("message", messageCallback, false);
  });
  return await applyTimeoutToPromise(promise, this.messageReceiveTimeout, "Timeout when waiting for 3rd party check iframe message.");
};
processInit_fn = async function(initOptions) {
  var _a, _b, _c;
  const callback = __privateMethod(this, _Keycloak_instances, parseCallback_fn).call(this, window.location.href);
  if (callback == null ? void 0 : callback.newUrl) {
    window.history.replaceState(window.history.state, "", callback.newUrl);
  }
  if (callback && callback.valid) {
    await __privateMethod(this, _Keycloak_instances, setupCheckLoginIframe_fn).call(this);
    await __privateMethod(this, _Keycloak_instances, processCallback_fn).call(this, callback);
    return;
  }
  const doLogin = async (prompt) => {
    const options = {};
    if (!prompt) {
      options.prompt = "none";
    }
    if (initOptions.locale) {
      options.locale = initOptions.locale;
    }
    await this.login(options);
  };
  const onLoad = async () => {
    switch (initOptions.onLoad) {
      case "check-sso":
        if (__privateGet(this, _loginIframe).enable) {
          await __privateMethod(this, _Keycloak_instances, setupCheckLoginIframe_fn).call(this);
          const unchanged = await __privateMethod(this, _Keycloak_instances, checkLoginIframe_fn).call(this);
          if (!unchanged) {
            this.silentCheckSsoRedirectUri ? await __privateMethod(this, _Keycloak_instances, checkSsoSilently_fn).call(this) : await doLogin(false);
          }
        } else {
          this.silentCheckSsoRedirectUri ? await __privateMethod(this, _Keycloak_instances, checkSsoSilently_fn).call(this) : await doLogin(false);
        }
        break;
      case "login-required":
        await doLogin(true);
        break;
      default:
        throw new Error("Invalid value for onLoad");
    }
  };
  if (initOptions.token && initOptions.refreshToken) {
    __privateMethod(this, _Keycloak_instances, setToken_fn).call(this, initOptions.token, initOptions.refreshToken, initOptions.idToken);
    if (__privateGet(this, _loginIframe).enable) {
      await __privateMethod(this, _Keycloak_instances, setupCheckLoginIframe_fn).call(this);
      const unchanged = await __privateMethod(this, _Keycloak_instances, checkLoginIframe_fn).call(this);
      if (unchanged) {
        (_a = this.onAuthSuccess) == null ? void 0 : _a.call(this);
        __privateMethod(this, _Keycloak_instances, scheduleCheckIframe_fn).call(this);
      }
    } else {
      try {
        await this.updateToken(-1);
        (_b = this.onAuthSuccess) == null ? void 0 : _b.call(this);
      } catch (error) {
        (_c = this.onAuthError) == null ? void 0 : _c.call(this);
        if (initOptions.onLoad) {
          await onLoad();
        } else {
          throw error;
        }
      }
    }
  } else if (initOptions.onLoad) {
    await onLoad();
  }
};
setupCheckLoginIframe_fn = async function() {
  if (!__privateGet(this, _loginIframe).enable || __privateGet(this, _loginIframe).iframe) {
    return;
  }
  const iframe = document.createElement("iframe");
  __privateGet(this, _loginIframe).iframe = iframe;
  iframe.setAttribute("src", this.endpoints.checkSessionIframe());
  iframe.setAttribute("sandbox", "allow-storage-access-by-user-activation allow-scripts allow-same-origin");
  iframe.setAttribute("title", "keycloak-session-iframe");
  iframe.style.display = "none";
  document.body.appendChild(iframe);
  const messageCallback = (event) => {
    var _a;
    if (event.origin !== __privateGet(this, _loginIframe).iframeOrigin || ((_a = __privateGet(this, _loginIframe).iframe) == null ? void 0 : _a.contentWindow) !== event.source) {
      return;
    }
    if (!(event.data === "unchanged" || event.data === "changed" || event.data === "error")) {
      return;
    }
    if (event.data !== "unchanged") {
      this.clearToken();
    }
    const callbacks = __privateGet(this, _loginIframe).callbackList;
    __privateGet(this, _loginIframe).callbackList = [];
    for (const callback of callbacks.reverse()) {
      if (event.data === "error") {
        callback(new Error("Error while checking login iframe"));
      } else {
        callback(null, event.data === "unchanged");
      }
    }
  };
  window.addEventListener("message", messageCallback, false);
  const promise = new Promise((resolve) => {
    iframe.addEventListener("load", () => {
      const authUrl = this.endpoints.authorize();
      if (authUrl.startsWith("/")) {
        __privateGet(this, _loginIframe).iframeOrigin = globalThis.location.origin;
      } else {
        __privateGet(this, _loginIframe).iframeOrigin = new URL(authUrl).origin;
      }
      resolve();
    });
  });
  await promise;
};
checkLoginIframe_fn = async function() {
  if (!__privateGet(this, _loginIframe).iframe || !__privateGet(this, _loginIframe).iframeOrigin) {
    return;
  }
  const message = `${this.clientId} ${this.sessionId ? this.sessionId : ""}`;
  const origin = __privateGet(this, _loginIframe).iframeOrigin;
  const promise = new Promise((resolve, reject) => {
    var _a, _b;
    const callback = (error, result) => error ? reject(error) : resolve(
      /** @type {boolean} */
      result
    );
    __privateGet(this, _loginIframe).callbackList.push(callback);
    if (__privateGet(this, _loginIframe).callbackList.length === 1) {
      (_b = (_a = __privateGet(this, _loginIframe).iframe) == null ? void 0 : _a.contentWindow) == null ? void 0 : _b.postMessage(message, origin);
    }
  });
  return await promise;
};
checkSsoSilently_fn = async function() {
  const iframe = document.createElement("iframe");
  const src = await this.createLoginUrl({ prompt: "none", redirectUri: this.silentCheckSsoRedirectUri });
  iframe.setAttribute("src", src);
  iframe.setAttribute("sandbox", "allow-storage-access-by-user-activation allow-scripts allow-same-origin");
  iframe.setAttribute("title", "keycloak-silent-check-sso");
  iframe.style.display = "none";
  document.body.appendChild(iframe);
  return await new Promise((resolve, reject) => {
    const messageCallback = async (event) => {
      if (event.origin !== window.location.origin || iframe.contentWindow !== event.source) {
        return;
      }
      const oauth = __privateMethod(this, _Keycloak_instances, parseCallback_fn).call(this, event.data);
      try {
        await __privateMethod(this, _Keycloak_instances, processCallback_fn).call(this, oauth);
        resolve();
      } catch (error) {
        reject(error);
      }
      document.body.removeChild(iframe);
      window.removeEventListener("message", messageCallback);
    };
    window.addEventListener("message", messageCallback);
  });
};
/**
 * @param {string} url
 */
parseCallback_fn = function(url) {
  const oauth = __privateMethod(this, _Keycloak_instances, parseCallbackUrl_fn).call(this, url);
  if (!oauth) {
    return;
  }
  const oauthState = __privateGet(this, _callbackStorage).get(oauth.state);
  if (oauthState) {
    oauth.valid = true;
    oauth.redirectUri = oauthState.redirectUri;
    oauth.storedNonce = oauthState.nonce;
    oauth.prompt = oauthState.prompt;
    oauth.pkceCodeVerifier = oauthState.pkceCodeVerifier;
    oauth.loginOptions = oauthState.loginOptions;
  }
  return oauth;
};
/**
 * @param {string} urlString
 */
parseCallbackUrl_fn = function(urlString) {
  let supportedParams = [];
  switch (this.flow) {
    case "standard":
      supportedParams = ["code", "state", "session_state", "kc_action_status", "kc_action", "iss"];
      break;
    case "implicit":
      supportedParams = ["access_token", "token_type", "id_token", "state", "session_state", "expires_in", "kc_action_status", "kc_action", "iss"];
      break;
    case "hybrid":
      supportedParams = ["access_token", "token_type", "id_token", "code", "state", "session_state", "expires_in", "kc_action_status", "kc_action", "iss"];
      break;
  }
  supportedParams.push("error");
  supportedParams.push("error_description");
  supportedParams.push("error_uri");
  const url = new URL(urlString);
  let newUrl = "";
  let parsed;
  if (this.responseMode === "query" && url.searchParams.size > 0) {
    parsed = __privateMethod(this, _Keycloak_instances, parseCallbackParams_fn).call(this, url.search, supportedParams);
    url.search = parsed.paramsString;
    newUrl = url.toString();
  } else if (this.responseMode === "fragment" && url.hash.length > 0) {
    parsed = __privateMethod(this, _Keycloak_instances, parseCallbackParams_fn).call(this, url.hash.substring(1), supportedParams);
    url.hash = parsed.paramsString;
    newUrl = url.toString();
  }
  if (parsed == null ? void 0 : parsed.oauthParams) {
    if (this.flow === "standard" || this.flow === "hybrid") {
      if ((parsed.oauthParams.code || parsed.oauthParams.error) && parsed.oauthParams.state) {
        parsed.oauthParams.newUrl = newUrl;
        return parsed.oauthParams;
      }
    } else if (this.flow === "implicit") {
      if ((parsed.oauthParams.access_token || parsed.oauthParams.error) && parsed.oauthParams.state) {
        parsed.oauthParams.newUrl = newUrl;
        return parsed.oauthParams;
      }
    }
  }
};
/**
 * @typedef {Object} ParsedCallbackParams
 * @property {string} paramsString
 * @property {Record<string, string | undefined>} oauthParams
 */
/**
 * @param {string} paramsString
 * @param {string[]} supportedParams
 * @returns {ParsedCallbackParams}
 */
parseCallbackParams_fn = function(paramsString, supportedParams) {
  const params = new URLSearchParams(paramsString);
  const oauthParams = {};
  for (const [key, value] of Array.from(params.entries())) {
    if (supportedParams.includes(key)) {
      oauthParams[key] = value;
      params.delete(key);
    }
  }
  return {
    paramsString: params.toString(),
    oauthParams
  };
};
processCallback_fn = async function(oauth) {
  var _a, _b, _c, _d;
  const { code, error, prompt } = oauth;
  let timeLocal = (/* @__PURE__ */ new Date()).getTime();
  const authSuccess = (accessToken, refreshToken, idToken) => {
    timeLocal = (timeLocal + (/* @__PURE__ */ new Date()).getTime()) / 2;
    __privateMethod(this, _Keycloak_instances, setToken_fn).call(this, accessToken, refreshToken, idToken, timeLocal);
    if (__privateGet(this, _useNonce) && (this.idTokenParsed && this.idTokenParsed.nonce !== oauth.storedNonce)) {
      __privateGet(this, _logInfo).call(this, "[KEYCLOAK] Invalid nonce, clearing token");
      this.clearToken();
      throw new Error("Invalid nonce.");
    }
  };
  if (oauth.kc_action_status) {
    this.onActionUpdate && this.onActionUpdate(oauth.kc_action_status, oauth.kc_action);
  }
  if (error) {
    if (prompt !== "none") {
      if (oauth.error_description && oauth.error_description === "authentication_expired") {
        await this.login(oauth.loginOptions);
      } else {
        const errorData = { error, error_description: oauth.error_description };
        (_a = this.onAuthError) == null ? void 0 : _a.call(this, errorData);
        throw errorData;
      }
    }
    return;
  } else if (this.flow !== "standard" && (oauth.access_token || oauth.id_token)) {
    authSuccess(oauth.access_token, void 0, oauth.id_token);
    (_b = this.onAuthSuccess) == null ? void 0 : _b.call(this);
  }
  if (this.flow !== "implicit" && code) {
    try {
      const response = await fetchAccessToken(
        this.endpoints.token(),
        code,
        /** @type {string} */
        this.clientId,
        oauth.redirectUri,
        oauth.pkceCodeVerifier
      );
      authSuccess(response.access_token, response.refresh_token, response.id_token);
      if (this.flow === "standard") {
        (_c = this.onAuthSuccess) == null ? void 0 : _c.call(this);
      }
      __privateMethod(this, _Keycloak_instances, scheduleCheckIframe_fn).call(this);
    } catch (error2) {
      (_d = this.onAuthError) == null ? void 0 : _d.call(this);
      throw error2;
    }
  }
};
scheduleCheckIframe_fn = async function() {
  if (__privateGet(this, _loginIframe).enable && this.token) {
    await waitForTimeout(__privateGet(this, _loginIframe).interval * 1e3);
    const unchanged = await __privateMethod(this, _Keycloak_instances, checkLoginIframe_fn).call(this);
    if (unchanged) {
      await __privateMethod(this, _Keycloak_instances, scheduleCheckIframe_fn).call(this);
    }
  }
};
/**
 * @param {string} [token]
 * @param {string} [refreshToken]
 * @param {string} [idToken]
 * @param {number} [timeLocal]
 */
setToken_fn = function(token, refreshToken, idToken, timeLocal) {
  if (this.tokenTimeoutHandle) {
    clearTimeout(this.tokenTimeoutHandle);
    this.tokenTimeoutHandle = void 0;
  }
  if (refreshToken) {
    this.refreshToken = refreshToken;
    this.refreshTokenParsed = decodeToken(refreshToken);
  } else {
    delete this.refreshToken;
    delete this.refreshTokenParsed;
  }
  if (idToken) {
    this.idToken = idToken;
    this.idTokenParsed = decodeToken(idToken);
  } else {
    delete this.idToken;
    delete this.idTokenParsed;
  }
  if (token) {
    this.token = token;
    this.tokenParsed = decodeToken(token);
    this.sessionId = this.tokenParsed.sid;
    this.authenticated = true;
    this.subject = this.tokenParsed.sub;
    this.realmAccess = this.tokenParsed.realm_access;
    this.resourceAccess = this.tokenParsed.resource_access;
    if (timeLocal) {
      this.timeSkew = Math.floor(timeLocal / 1e3) - this.tokenParsed.iat;
    }
    if (this.timeSkew !== null) {
      __privateGet(this, _logInfo).call(this, "[KEYCLOAK] Estimated time difference between browser and server is " + this.timeSkew + " seconds");
      if (this.onTokenExpired) {
        const expiresIn = (this.tokenParsed.exp - (/* @__PURE__ */ new Date()).getTime() / 1e3 + this.timeSkew) * 1e3;
        __privateGet(this, _logInfo).call(this, "[KEYCLOAK] Token expires in " + Math.round(expiresIn / 1e3) + " s");
        if (expiresIn <= 0) {
          this.onTokenExpired();
        } else {
          this.tokenTimeoutHandle = window.setTimeout(this.onTokenExpired, expiresIn);
        }
      }
    }
  } else {
    delete this.token;
    delete this.tokenParsed;
    delete this.subject;
    delete this.realmAccess;
    delete this.resourceAccess;
    this.authenticated = false;
  }
};
/**
 * @returns {string=}
 */
getRealmUrl_fn = function() {
  if (typeof this.authServerUrl === "undefined") {
    return;
  }
  return `${stripTrailingSlash(this.authServerUrl)}/realms/${encodeURIComponent(
    /** @type {string} */
    this.realm
  )}`;
};
/**
 * @param {Function} fn
 * @returns {(message: string) => void}
 */
createLogger_fn = function(fn) {
  return (message) => {
    if (this.enableLogging) {
      fn.call(console, message);
    }
  };
};
function createUUID() {
  if (typeof crypto === "undefined" || typeof crypto.randomUUID === "undefined") {
    throw new Error("Web Crypto API is not available.");
  }
  return crypto.randomUUID();
}
function buildClaimsParameter(requestedAcr) {
  return JSON.stringify({
    id_token: {
      acr: requestedAcr
    }
  });
}
function generateCodeVerifier(len) {
  return generateRandomString(len, "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789");
}
async function generatePkceChallenge(pkceMethod, codeVerifier) {
  if (pkceMethod !== "S256") {
    throw new TypeError(`Invalid value for 'pkceMethod', expected 'S256' but got '${pkceMethod}'.`);
  }
  const hashBytes = new Uint8Array(await sha256Digest(codeVerifier));
  const encodedHash = bytesToBase64(hashBytes).replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
  return encodedHash;
}
function generateRandomString(len, alphabet) {
  const randomData = generateRandomData(len);
  const chars = new Array(len);
  for (let i = 0; i < len; i++) {
    chars[i] = alphabet.charCodeAt(randomData[i] % alphabet.length);
  }
  return String.fromCharCode.apply(null, chars);
}
function generateRandomData(len) {
  if (typeof crypto === "undefined" || typeof crypto.getRandomValues === "undefined") {
    throw new Error("Web Crypto API is not available.");
  }
  return crypto.getRandomValues(new Uint8Array(len));
}
function applyTimeoutToPromise(promise, timeout, errorMessage) {
  let timeoutHandle;
  const timeoutPromise = new Promise(function(resolve, reject) {
    timeoutHandle = window.setTimeout(function() {
      reject(new Error(errorMessage || "Promise is not settled within timeout of " + timeout + "ms"));
    }, timeout);
  });
  return Promise.race([promise, timeoutPromise]).finally(function() {
    clearTimeout(timeoutHandle);
  });
}
function createCallbackStorage() {
  try {
    return new LocalStorage();
  } catch (err) {
    return new CookieStorage();
  }
}
var STORAGE_KEY_PREFIX = "kc-callback-";
var _LocalStorage_instances, clearInvalidValues_fn, clearAllValues_fn, getStoredEntries_fn, parseExpiry_fn;
var LocalStorage = class {
  constructor() {
    __privateAdd(this, _LocalStorage_instances);
    globalThis.localStorage.setItem("kc-test", "test");
    globalThis.localStorage.removeItem("kc-test");
  }
  /**
   * @param {string} [state]
   * @returns {CallbackState | null}
   */
  get(state) {
    if (!state) {
      return null;
    }
    __privateMethod(this, _LocalStorage_instances, clearInvalidValues_fn).call(this);
    const key = STORAGE_KEY_PREFIX + state;
    const value = globalThis.localStorage.getItem(key);
    if (value) {
      globalThis.localStorage.removeItem(key);
      return JSON.parse(value);
    }
    return null;
  }
  /**
   * @param {CallbackState} state
   */
  add(state) {
    __privateMethod(this, _LocalStorage_instances, clearInvalidValues_fn).call(this);
    const key = STORAGE_KEY_PREFIX + state.state;
    const value = JSON.stringify({
      ...state,
      // Set the expiry time to 1 hour from now.
      expires: Date.now() + 60 * 60 * 1e3
    });
    try {
      globalThis.localStorage.setItem(key, value);
    } catch (error) {
      __privateMethod(this, _LocalStorage_instances, clearAllValues_fn).call(this);
      globalThis.localStorage.setItem(key, value);
    }
  }
};
_LocalStorage_instances = new WeakSet();
/**
 * Clears all values from local storage that are no longer valid.
 */
clearInvalidValues_fn = function() {
  const currentTime = Date.now();
  for (const [key, value] of __privateMethod(this, _LocalStorage_instances, getStoredEntries_fn).call(this)) {
    const expiry = __privateMethod(this, _LocalStorage_instances, parseExpiry_fn).call(this, value);
    if (expiry === null || expiry < currentTime) {
      globalThis.localStorage.removeItem(key);
    }
  }
};
/**
 * Clears all known values from local storage.
 */
clearAllValues_fn = function() {
  for (const [key] of __privateMethod(this, _LocalStorage_instances, getStoredEntries_fn).call(this)) {
    globalThis.localStorage.removeItem(key);
  }
};
/**
 * Gets all entries stored in local storage that are known to be managed by this class.
 * @returns {[string, string][]} An array of key-value pairs.
 */
getStoredEntries_fn = function() {
  return Object.entries(globalThis.localStorage).filter(([key]) => key.startsWith(STORAGE_KEY_PREFIX));
};
/**
 * Parses the expiry time from a value stored in local storage.
 * @param {string} value
 * @returns {number | null} The expiry time in milliseconds, or `null` if the value is malformed.
 */
parseExpiry_fn = function(value) {
  let parsedValue;
  try {
    parsedValue = JSON.parse(value);
  } catch (error) {
    return null;
  }
  if (isObject(parsedValue) && "expires" in parsedValue && typeof parsedValue.expires === "number") {
    return parsedValue.expires;
  }
  return null;
};
var _CookieStorage_instances, getCookie_fn, setCookie_fn, cookieExpiration_fn;
var CookieStorage = class {
  constructor() {
    __privateAdd(this, _CookieStorage_instances);
  }
  /**
   * @param {string} [state]
   * @returns {CallbackState | null}
   */
  get(state) {
    if (!state) {
      return null;
    }
    const value = __privateMethod(this, _CookieStorage_instances, getCookie_fn).call(this, STORAGE_KEY_PREFIX + state);
    __privateMethod(this, _CookieStorage_instances, setCookie_fn).call(this, STORAGE_KEY_PREFIX + state, "", __privateMethod(this, _CookieStorage_instances, cookieExpiration_fn).call(this, -100));
    if (value) {
      return JSON.parse(value);
    }
    return null;
  }
  /**
   * @param {CallbackState} state
   */
  add(state) {
    __privateMethod(this, _CookieStorage_instances, setCookie_fn).call(this, STORAGE_KEY_PREFIX + state.state, JSON.stringify(state), __privateMethod(this, _CookieStorage_instances, cookieExpiration_fn).call(this, 60));
  }
};
_CookieStorage_instances = new WeakSet();
/**
 * @param {string} key
 * @returns
 */
getCookie_fn = function(key) {
  const name = key + "=";
  const ca = document.cookie.split(";");
  for (let i = 0; i < ca.length; i++) {
    let c = ca[i];
    while (c.charAt(0) === " ") {
      c = c.substring(1);
    }
    if (c.indexOf(name) === 0) {
      return c.substring(name.length, c.length);
    }
  }
  return "";
};
/**
 * @param {string} key
 * @param {string} value
 * @param {Date} expirationDate
 */
setCookie_fn = function(key, value, expirationDate) {
  const cookie = key + "=" + value + "; expires=" + expirationDate.toUTCString() + "; ";
  document.cookie = cookie;
};
/**
 * @param {number} minutes
 * @returns {Date}
 */
cookieExpiration_fn = function(minutes) {
  const exp = /* @__PURE__ */ new Date();
  exp.setTime(exp.getTime() + minutes * 60 * 1e3);
  return exp;
};
function bytesToBase64(bytes) {
  const binString = String.fromCodePoint(...bytes);
  return btoa(binString);
}
async function sha256Digest(message) {
  const encoder = new TextEncoder();
  const data = encoder.encode(message);
  if (typeof crypto === "undefined" || typeof crypto.subtle === "undefined") {
    throw new Error("Web Crypto API is not available.");
  }
  return await crypto.subtle.digest("SHA-256", data);
}
function decodeToken(token) {
  const [, payload] = token.split(".");
  if (typeof payload !== "string") {
    throw new Error("Unable to decode token, payload not found.");
  }
  let decoded;
  try {
    decoded = base64UrlDecode(payload);
  } catch (error) {
    throw new Error("Unable to decode token, payload is not a valid Base64URL value.", { cause: error });
  }
  try {
    return JSON.parse(decoded);
  } catch (error) {
    throw new Error("Unable to decode token, payload is not a valid JSON value.", { cause: error });
  }
}
function base64UrlDecode(input) {
  let output = input.replaceAll("-", "+").replaceAll("_", "/");
  switch (output.length % 4) {
    case 0:
      break;
    case 2:
      output += "==";
      break;
    case 3:
      output += "=";
      break;
    default:
      throw new Error("Input is not of the correct length.");
  }
  try {
    return b64DecodeUnicode(output);
  } catch (error) {
    return atob(output);
  }
}
function b64DecodeUnicode(input) {
  return decodeURIComponent(atob(input).replace(/(.)/g, (m, p) => {
    let code = p.charCodeAt(0).toString(16).toUpperCase();
    if (code.length < 2) {
      code = "0" + code;
    }
    return "%" + code;
  }));
}
function isObject(input) {
  return typeof input === "object" && input !== null;
}
async function fetchJsonConfig(url) {
  return await fetchJSON(url);
}
async function fetchOpenIdConfig(url) {
  return await fetchJSON(url);
}
async function fetchAccessToken(url, code, clientId, redirectUri, pkceCodeVerifier) {
  const body = new URLSearchParams([
    ["code", code],
    ["grant_type", "authorization_code"],
    ["client_id", clientId],
    ["redirect_uri", redirectUri]
  ]);
  if (pkceCodeVerifier) {
    body.append("code_verifier", pkceCodeVerifier);
  }
  return await fetchJSON(url, {
    method: "POST",
    credentials: "include",
    body
  });
}
async function fetchRefreshToken(url, refreshToken, clientId) {
  const body = new URLSearchParams([
    ["grant_type", "refresh_token"],
    ["refresh_token", refreshToken],
    ["client_id", clientId]
  ]);
  return await fetchJSON(url, {
    method: "POST",
    credentials: "include",
    body
  });
}
async function fetchJSON(url, init = {}) {
  const headers = new Headers(init.headers);
  headers.set("Accept", CONTENT_TYPE_JSON);
  const response = await fetchWithErrorHandling(url, {
    ...init,
    headers
  });
  return await response.json();
}
async function fetchWithErrorHandling(url, init) {
  const response = await fetch(url, init);
  if (!response.ok) {
    throw new NetworkError("Server responded with an invalid status.", { response });
  }
  return response;
}
function buildAuthorizationHeader(token) {
  if (!token) {
    throw new Error("Unable to build authorization header, token is not set, make sure the user is authenticated.");
  }
  return ["Authorization", `bearer ${token}`];
}
function stripTrailingSlash(url) {
  return url.endsWith("/") ? url.slice(0, -1) : url;
}
var NetworkError = class extends Error {
  /**
   * @param {string} message
   * @param {NetworkErrorOptions} options
   */
  constructor(message, options) {
    super(message, options);
    /** @type {Response} */
    __publicField(this, "response");
    this.response = options.response;
  }
};
var waitForTimeout = (delay) => new Promise((resolve) => setTimeout(resolve, delay));
export {
  NetworkError,
  Keycloak as default
};
//# sourceMappingURL=keycloak-js.js.map
